import numpy as np


class QPSKDemapper:
    """
    QPSK Demapper (hard decision)

    Inverzni korak QPSK mapiranja korištenog u PBCHEncoder.qpsk().

    Mapiranje u encoderu:
        I = 1 - 2*b0
        Q = 1 - 2*b1

    Inverzno (hard decision):
        b0 = 0 ako I > 0, inače 1
        b1 = 0 ako Q > 0, inače 1
    """

    def __init__(self, mode="hard"):
        """
        Parametri
        ----------
        mode : str
            Trenutno podržan samo "hard" (hard-decision demapping)
        """
        if mode != "hard":
            raise NotImplementedError("Trenutno je podržan samo hard demapping")

        self.mode = mode

    # ==============================================================
    # QPSK DEMAPIRANJE
    # ==============================================================

    def demap(self, symbols):
        """
        Demapira QPSK simbole u bitove.

        Parametri
        ----------
        symbols : numpy.ndarray of complex
            QPSK simboli (npr. izlaz OFDM demodulatora nakon equalizacije)

        Povrat
        -------
        bits : numpy.ndarray of uint8
            Demapirani bitovi (0/1), duljine 2 * broj_simbola
        """

        # Osiguraj numpy kompleksni tip
        symbols = np.asarray(symbols, dtype=np.complex64)

        # --------------------------------------------------
        # 1. I i Q komponente
        # --------------------------------------------------
        I = np.real(symbols)
        Q = np.imag(symbols)

        # --------------------------------------------------
        # 2. Hard decision prema PBCH QPSK mapiranju
        #
        # Encoder:
        #   I = +1 → bit 0
        #   I = -1 → bit 1
        #
        # Dakle:
        #   bit = 0 ako je komponenta > 0
        #   bit = 1 ako je komponenta <= 0
        # --------------------------------------------------
        b0 = (I <= 0).astype(np.uint8)
        b1 = (Q <= 0).astype(np.uint8)

        # --------------------------------------------------
        # 3. Spajanje bitova u izlazni niz
        #    (svaki simbol → 2 bita)
        # --------------------------------------------------
        bits = np.empty(2 * len(symbols), dtype=np.uint8)
        bits[0::2] = b0
        bits[1::2] = b1

        return bits


# ==============================================================
# PRIMJERI KORIŠTENJA (NumPy stil, dokumentacijski primjer)
# ==============================================================

# Pretpostavimo da su QPSK simboli dobiveni nakon OFDM demodulacije
# i idealne equalizacije (bez šuma).

# QPSK simboli (I + jQ) i pripadajući bitovi:
#   1 + 1j   → b0=0, b1=0
#  -1 + 1j   → b0=1, b1=0
#   1 - 1j   → b0=0, b1=1
#  -1 - 1j   → b0=1, b1=1

symbols = np.array([
    1 + 1j,
   -1 + 1j,
    1 - 1j,
   -1 - 1j
], dtype=np.complex64)

# Inicijalizacija demappera
demapper = QPSKDemapper(mode="hard")

# Demapiranje simbola u bitove
bits = demapper.demap(symbols)

# Očekivani rezultat:
# bits = np.array([0, 0, 1, 0, 0, 1, 1, 1], dtype=np.uint8)

# Napomena:
# - Izlazni niz ima duljinu 2 * broj_simbola
# - bits[0::2] odgovara I-komponenti (b0)
# - bits[1::2] odgovara Q-komponenti (b1)
